1. Exercise 1.8
--
In order to design a system to run an entire Operating System (OS) as an
application on top of another OS we need to carefully consider virtualization.
Ideally, we should build a system whose base OS is capable of acting as a
Virtual Machine Monitor (VMM), also known as Hypervisor (HV), and can run
another OS as if it were an application program. The base OS is called host OS
and it provides the guest OS, running as an application program, with the
illusion that it has full control of the physical hardware.


2. Exercise 1.13
--
I am currently using a portable workstation and in my opinion OS designer
should prioritize as follows:
(1) Reliability is the most important requirement that my OS should meet, since
I expect it to do exactly and only what I ask it to.
(2) Security is also very important, since I need to be sure that my system,
and thus my personal data, are safe from external attackers. In our days, where
users are constantly connected to the Internet, security is arguably of
principal importance.
(3) Performance is slightly less important than Reliability and Security, but
still it remains of essential concern and is clearly a requirement expected to
be fulfilled.
(4) Portability is less important than the previous three requirement because
we are examining one specific system (a PC) whose hardware is not expected to
change regularly through time. However, clearly, portability is a desired
characteristic.
(5) Adoption is desired characteristic for my system, but can be tolerated if
not met. I am using a Personal Computer and in most cases I am the single one
user logged into it. This diminishes the importance of adoption in comparison
with the previous requirements.


3. Exercise 3.1
--
UNIX fork can return an error.
Fork is a system call with which a program requests from the Operating System
(OS) to create a new process by duplicating (creating a child of) the calling
process. Being a request to the OS, there is no guarantee that fork will
be successfully fulfilled, and thus there should be a mechanism indicating the
status of this request. This mechanism should be the return value of the fork
system call indicating whether an error occurred or not.

Additionally, from the manual page of fork(2): "On failure, -1 is returned  in
the parent, no  child process is created, and errno is set appropriately"


4. Exercise 3.2
--
UNIX exec can return an error.
exec is a system call with which a program requests from the OS to overlay the
image of the calling process with the image of a new process (another program).
Being a request to the OS, there is no guarantee that exec will be successful,
and thus there should be a mechanism indicating whether exec succeeded or
failed. This mechanism should be the return value of the fork system call
indicating whether an error occurred or not.

Additionally, from the manual page of exec(2): "The exec() functions only
return if an error has have occurred. The return value is -1, and errno is
set to indicate the error."


5. Exercise 3.3
--
If we run the suggested program in a UNIX system it will be hanging and will
be unusable due to a very high number of forked processes. Unless there is
ulimit set restricting the max number of active processes per user, the OS
will be continuously requested to fork new processes and will appear non
responsive to all end users. Practically, what will happen is that the initial
parent process will be forking children until fork system call fails (return
-1). Also, any forked child will become a parent trying to fork other children,
which will in turn also be trying to fork until fork fails. Note that the
condition in while-loop is greater or equal to zero, meaning that children will
also be executing the while-loop. Consequently, the system will end up having
an extremely high number of forked processes requesting to fork again and again
making the system unusable.


6. Exercise 3.4
--
In order wait to return successfully and immediately the parent process should
wait for a child of his that has already terminated. That is, the parent should
invoke wait system call passing as argument the PID of a forked --by him--
child which has already terminated execution.


7. Exercise 3.7
--
When a user executes "exec ls" the image of the calling process (which is the
shell in which the user typed the command) is overlaid with the image of the
process corresponding to the  binary of "ls" command.  As a result the user
will see his terminal disappearing because the process in which the current
terminal lives is substituted with a process which will execute "ls" binary.


8. Exercise 3.8
--
There are 32 processed created if the suggested program is run.
The initial process invokes a recursive function "forkthem" which  checks the
value of a variable n which if greater than zero, (1) a new child process will
be forked and (2) "forkthem" will recursively invoke itself. Note that for
n == 0 there is one process, and for n == 1 there are two processes. Also, note
that the number of processes for n equals the sum  of the number of processes
for (n-1) and (n-2). This a Fibonacci sequence starting for which we drop the
first and the second term, and since we execute forkthem(n=5), we need to
calculate the sum: 1+2+3+5+8+13.
Thus, there are 32 processes created.


9. Exercise 3.9
--
There will be 3 copies of x's value in 3 distinct processes, since the initial
process will fork two children and these children processes will not fork.
At the parent, upon completion, x will equal to 20.
At the first child, upon completion, x will equal to 10.
At the second child, upon completion, x will equal to 15.


10. Exercise 3.10
--
Program 1 will print twice the value 6 (once the parent and once the child).
Program 2 will print once the value 6 ( the child prints nothing, since it
executes the else statement and exits immediately).


REFERENCES
--
1. Operating Systems: Principles and Practice (2nd Edition), Thomas Anderson
and Michael Dahlin, Recursive Books, West Lake Hills, TX, 2014

2. Linux  Programmer's Manual
